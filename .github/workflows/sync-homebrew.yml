name: sync-homebrew

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'The git tag name to bump the cask to (e.g., v1.2.3)'
        required: false
        type: string
      force:
        description: 'Force update even if version is not newer'
        required: false
        type: boolean
        default: false
  workflow_run:
    workflows: ['release-assets']
    types:
      - completed

env:
  GITHUB_REPO: viarotel-org/escrcpy
  HOMEBREW_TAP: viarotel-org/homebrew-escrcpy
  CASK_NAME: escrcpy
  MAX_RETRIES: 3
  RETRY_DELAY: 10

jobs:
  sync-homebrew:
    runs-on: macos-latest
    # Only run if workflow_run was successful or if manually triggered
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}

    steps:
    - name: Set up Homebrew
      uses: Homebrew/actions/setup-homebrew@master
      with:
        token: ${{ secrets.GH_TOKEN }}

    - name: Configure Git
      uses: Homebrew/actions/git-user-config@master
      with:
        username: viarotel
        token: ${{ secrets.GH_TOKEN }}

    - name: Determine version to update
      id: version
      uses: actions/github-script@v7
      env:
        MANUAL_TAG: ${{ github.event.inputs.tag }}
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          const { GITHUB_REPO, MANUAL_TAG } = process.env;
          const [owner, repo] = GITHUB_REPO.split('/');

          console.log('::group::Determining version to update');

          let releaseInfo, tagName, version;

          try {
            if (MANUAL_TAG && MANUAL_TAG.trim()) {
              console.log(`Using manually specified tag: ${MANUAL_TAG}`);
              tagName = MANUAL_TAG;

              // Validate manual tag exists
              console.log('Validating tag exists...');
              const tagRef = tagName.replace(/^refs\/tags\//, '');

              try {
                await github.rest.git.getRef({
                  owner,
                  repo,
                  ref: `tags/${tagRef}`
                });
                console.log(`✅ Tag ${tagName} exists`);
              } catch (error) {
                if (error.status === 404) {
                  core.setFailed(`Tag ${tagName} does not exist`);
                  return;
                } else {
                  throw error;
                }
              }

              // Get release info for manual tag
              version = tagRef.replace(/^v/, '');

              console.log(`Getting release info for tag: ${tagName}`);
              try {
                const releaseResponse = await github.rest.repos.getReleaseByTag({
                  owner,
                  repo,
                  tag: tagRef
                });
                releaseInfo = releaseResponse.data;
              } catch (error) {
                if (error.status === 404) {
                  core.setFailed(`Release for tag ${tagName} not found`);
                  return;
                } else {
                  throw error;
                }
              }
            } else {
              console.log('Getting latest release info...');
              try {
                const releaseResponse = await github.rest.repos.getLatestRelease({
                  owner,
                  repo
                });
                releaseInfo = releaseResponse.data;
                tagName = releaseInfo.tag_name;
                version = tagName.replace(/^v/, '');
              } catch (error) {
                if (error.status === 404) {
                  core.setFailed('No releases found for this repository');
                  return;
                } else {
                  throw error;
                }
              }
            }

            console.log(`Tag: ${tagName}`);
            console.log(`Version: ${version}`);

            // Validate version format
            const versionRegex = /^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$/;
            if (!versionRegex.test(version)) {
              core.setFailed(`Invalid version format: ${version}`);
              return;
            }

            // Check release assets
            const assetsCount = releaseInfo.assets ? releaseInfo.assets.length : 0;
            console.log(`Release has ${assetsCount} assets`);

            if (assetsCount === 0) {
              console.log(`::warning::Release ${tagName} has no assets, but continuing...`);
            } else {
              console.log('Release assets:');
              releaseInfo.assets.forEach(asset => {
                console.log(`  - ${asset.name}`);
              });
            }

            // Set outputs
            core.setOutput('tag_name', tagName);
            core.setOutput('version', version);
            core.setOutput('release_info', JSON.stringify(releaseInfo));

            console.log('::endgroup::');

          } catch (error) {
            console.log('::endgroup::');
            core.setFailed(`Failed to determine version: ${error.message}`);
          }

    - name: Add Homebrew tap
      env:
        HOMEBREW_GITHUB_API_TOKEN: ${{ secrets.GH_TOKEN }}
      run: |
        echo "::group::Adding Homebrew tap"
        echo "Adding Homebrew tap: $HOMEBREW_TAP"
        brew tap "$HOMEBREW_TAP"
        echo "::endgroup::"

    - name: Check current cask version
      id: current_version
      uses: actions/github-script@v7
      env:
        NEW_VERSION: ${{ steps.version.outputs.version }}
        FORCE_UPDATE: ${{ github.event.inputs.force }}
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          const { execSync } = require('child_process');
          const { HOMEBREW_TAP, CASK_NAME, NEW_VERSION, FORCE_UPDATE } = process.env;

          console.log('::group::Checking current cask version');

          try {
            // Get current cask version
            const brewInfoCmd = `brew info --json=v2 "${HOMEBREW_TAP}/${CASK_NAME}"`;
            console.log(`Running: ${brewInfoCmd}`);

            const brewOutput = execSync(brewInfoCmd, { encoding: 'utf8' });
            const brewInfo = JSON.parse(brewOutput);

            const currentVersion = brewInfo.casks && brewInfo.casks[0] && brewInfo.casks[0].version || '0.0.0';
            console.log(`Current cask version: ${currentVersion}`);
            console.log(`New version: ${NEW_VERSION}`);

            // Compare versions
            let needsUpdate = false;
            if (NEW_VERSION === currentVersion) {
              if (FORCE_UPDATE === 'true') {
                console.log('::warning::Versions are the same but force update is enabled');
                needsUpdate = true;
              } else {
                console.log(`::notice::Version ${NEW_VERSION} is already current, skipping update`);
                needsUpdate = false;
              }
            } else {
              console.log(`Version update needed: ${currentVersion} -> ${NEW_VERSION}`);
              needsUpdate = true;
            }

            // Set outputs
            core.setOutput('current_version', currentVersion);
            core.setOutput('needs_update', needsUpdate.toString());

            console.log('::endgroup::');

          } catch (error) {
            console.log('::endgroup::');
            core.setFailed(`Failed to check current cask version: ${error.message}`);
          }

    - name: Update Homebrew cask
      if: steps.current_version.outputs.needs_update == 'true'
      uses: actions/github-script@v7
      env:
        HOMEBREW_GITHUB_API_TOKEN: ${{ secrets.GH_TOKEN }}
        VERSION: ${{ steps.version.outputs.version }}
        TAG_NAME: ${{ steps.version.outputs.tag_name }}
        CURRENT_VERSION: ${{ steps.current_version.outputs.current_version }}
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          const { execSync, spawn } = require('child_process');
          const { HOMEBREW_TAP, CASK_NAME, VERSION, TAG_NAME, CURRENT_VERSION, MAX_RETRIES, RETRY_DELAY } = process.env;

          console.log('::group::Updating Homebrew cask');
          console.log(`Updating cask to version: ${VERSION}`);
          console.log(`Using tag: ${TAG_NAME}`);

          // Function to run brew command with retry
          const retryBrewCommand = async () => {
            const maxAttempts = parseInt(MAX_RETRIES) || 3;
            let delay = parseInt(RETRY_DELAY) || 10;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              console.log(`Brew command attempt ${attempt}/${maxAttempts}`);

              try {
                const brewCmd = [
                  'brew', 'bump-cask-pr',
                  '--no-browse',
                  '--no-audit',
                  `--version=${VERSION}`,
                  `${HOMEBREW_TAP}/${CASK_NAME}`
                ];

                console.log(`Running: ${brewCmd.join(' ')}`);

                // Use spawn with timeout
                const result = await new Promise((resolve, reject) => {
                  const process = spawn(brewCmd[0], brewCmd.slice(1), {
                    stdio: ['inherit', 'pipe', 'pipe'],
                    timeout: 300000 // 5 minutes
                  });

                  let stdout = '';
                  let stderr = '';

                  process.stdout.on('data', (data) => {
                    const output = data.toString();
                    console.log(output);
                    stdout += output;
                  });

                  process.stderr.on('data', (data) => {
                    const output = data.toString();
                    console.error(output);
                    stderr += output;
                  });

                  process.on('close', (code) => {
                    if (code === 0) {
                      resolve({ stdout, stderr, code });
                    } else {
                      reject(new Error(`Process exited with code ${code}\nstdout: ${stdout}\nstderr: ${stderr}`));
                    }
                  });

                  process.on('error', (error) => {
                    reject(error);
                  });
                });

                console.log(`::notice::Successfully updated cask to version ${VERSION}`);
                return true;

              } catch (error) {
                console.log(`::warning::Brew command failed: ${error.message}`);

                if (attempt < maxAttempts) {
                  console.log(`Retrying in ${delay}s...`);
                  await new Promise(resolve => setTimeout(resolve, delay * 1000));
                  delay *= 2; // Exponential backoff
                } else {
                  throw error;
                }
              }
            }

            throw new Error(`Failed to update cask after ${maxAttempts} attempts`);
          };

          try {
            await retryBrewCommand();
            console.log(`::notice::Homebrew cask update completed successfully`);
            console.log(`::notice::Updated from ${CURRENT_VERSION} to ${VERSION}`);
            console.log('::endgroup::');

          } catch (error) {
            console.log('::endgroup::');
            core.setFailed(`Failed to update Homebrew cask: ${error.message}`);
          }

    - name: Verify update
      if: steps.current_version.outputs.needs_update == 'true'
      uses: actions/github-script@v7
      env:
        HOMEBREW_GITHUB_API_TOKEN: ${{ secrets.GH_TOKEN }}
        EXPECTED_VERSION: ${{ steps.version.outputs.version }}
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          const { execSync } = require('child_process');
          const { HOMEBREW_TAP, CASK_NAME, EXPECTED_VERSION } = process.env;

          console.log('::group::Verifying cask update');

          try {
            // Wait a moment for the update to propagate
            console.log('Waiting 5 seconds for update to propagate...');
            await new Promise(resolve => setTimeout(resolve, 5000));

            // Check the updated version
            const brewInfoCmd = `brew info --json=v2 "${HOMEBREW_TAP}/${CASK_NAME}"`;
            console.log(`Running: ${brewInfoCmd}`);

            const brewOutput = execSync(brewInfoCmd, { encoding: 'utf8' });
            const brewInfo = JSON.parse(brewOutput);

            const updatedVersion = brewInfo.casks && brewInfo.casks[0] && brewInfo.casks[0].version || 'unknown';
            console.log(`Verified cask version: ${updatedVersion}`);

            if (updatedVersion === EXPECTED_VERSION) {
              console.log('::notice::✅ Cask update verified successfully');
            } else {
              console.log(`::warning::⚠️ Version mismatch after update. Expected: ${EXPECTED_VERSION}, Got: ${updatedVersion}`);
            }

            console.log('::endgroup::');

          } catch (error) {
            console.log('::endgroup::');
            console.log(`::warning::Failed to verify update: ${error.message}`);
          }

    - name: Summary
      if: always()
      uses: actions/github-script@v7
      env:
        TARGET_VERSION: ${{ steps.version.outputs.version }}
        CURRENT_VERSION: ${{ steps.current_version.outputs.current_version }}
        NEEDS_UPDATE: ${{ steps.current_version.outputs.needs_update }}
        WORKFLOW_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          const {
            GITHUB_REPO,
            HOMEBREW_TAP,
            CASK_NAME,
            TARGET_VERSION,
            CURRENT_VERSION,
            NEEDS_UPDATE,
            WORKFLOW_CONCLUSION
          } = process.env;

          console.log('::group::Workflow Summary');
          console.log(`Trigger: ${context.eventName}`);

          if (context.eventName === 'workflow_run') {
            console.log(`Workflow run conclusion: ${WORKFLOW_CONCLUSION || 'unknown'}`);
          }

          if (TARGET_VERSION) {
            console.log(`Target version: ${TARGET_VERSION}`);
            console.log(`Current version: ${CURRENT_VERSION || 'unknown'}`);
            console.log(`Update needed: ${NEEDS_UPDATE || 'unknown'}`);
          } else {
            console.log('Version information not available (likely due to earlier failure)');
          }

          console.log(`Repository: ${GITHUB_REPO}`);
          console.log(`Homebrew tap: ${HOMEBREW_TAP}`);
          console.log(`Cask name: ${CASK_NAME}`);
          console.log('::endgroup::');